# üìã AN√ÅLISIS FORENSE DE LOGS - VoiceBot Quintero
**Fecha:** 2026-01-22 13:49:44 UTC  
**Session ID:** 1769089784.1506  
**ANI:** 966247067 | **DNIS:** 9001  
**Proceso:** telephony-core[1590477]

---

## 1) CONTEXTO GENERAL DEL FLUJO

**Tipo de llamada:** Inbound  
**Dominio:** Quintero (voicebot_quintero_query)  
**Objetivo:** Greeting ‚Üí LISTEN_RUT (captura RUT incremental)  
**Componentes activos:**
- Engine V3 (realtime STT)
- Dominio Quintero (phased-capsule)
- ARI (Stasis, Bridge, Snoop)
- Canal salida: VoiceBridge 2b54f137-... (Playback WAV)
- Canal entrada: Snoop 1769089785.1507 (RX, contrato READY)
- Redis (estado, contratos)
- MSSQL (finalizaci√≥n)

**Flujo esperado:** START_GREETING (playback) ‚Üí LISTEN_RUT (STT incremental) ‚Üí Captura RUT ‚Üí Webhook

---

## 2) SECUENCIA CRONOL√ìGICA RESUMIDA

**T0 (13:49:44.875)** ‚Üí StasisStart caller 1769089784.1506 | Router ‚Üí Quintero Capsule  
**T1 (13:49:45.434)** ‚Üí Engine setea fase START_GREETING | Dominio decide PLAY_AUDIO greeting  
**T2 (13:49:45.450)** ‚Üí VoiceBridge creado 2b54f137-... | CaptureBridge creado 787b5731-...  
**T3 (13:49:45.453)** ‚Üí Snoop RX creado temprano 1769089785.1507 (early_init_pre_warm)  
**T4 (13:49:45.458)** ‚Üí StasisStart RAW (SNOOP) recibido | SnoopContract CREATED ‚Üí READY  
**T5 (13:49:45.625)** ‚Üí Playback greeting iniciado (bridge.play) | STT pausado  
**T6 (13:49:55.333)** ‚Üí Playback completado (9696ms) | STT reanudado  
**T7 (13:49:55.543)** ‚Üí Turn 1 (silent, skipInput=true) | Dominio procesa TURN en LISTEN_RUT  
**T8 (13:49:55.556)** ‚Üí Turn 2 | Engine intenta STT init | AudioSource = 1769089785.1507 (READY)  
**T9 (13:49:55.576)** ‚Üí Audio-Safe Gate inicia | Espera materializaci√≥n ARI (timeout 5000ms)  
**T10 (13:50:00.666)** ‚Üí Audio-Safe Gate timeout | STT_BLOCKED_AUDIO_NOT_READY | Reintento 1/3  
**T11 (13:50:01.184)** ‚Üí Reintento 2 | Audio-Safe Gate inicia nuevamente  
**T12 (13:50:03.800)** ‚Üí Caller hangup | Cleanup | Llamada finaliza sin STT activo

---

## 3) COSAS QUE FUNCIONAN CORRECTAMENTE

‚úÖ **Router y C√°psula:** Routing a Quintero Capsule v√°lido, contrato normalizado correctamente  
‚úÖ **Lifecycle Gating:** START_GREETING valida PLAYBACK permitido + BRIDGE requerido antes de ejecutar  
‚úÖ **Bridge Creation:** VoiceBridge y CaptureBridge creados sin errores, tipos correctos (mixing,dtmf_events)  
‚úÖ **Snoop Creation:** Snoop RX creado temprano, StasisStart recibido, contrato transiciona CREATED ‚Üí READY  
‚úÖ **Playback Execution:** Archivo WAV existe, bridge.play() exitoso, PlaybackStarted confirmado, duraci√≥n 9696ms  
‚úÖ **STT Pause/Resume:** STT pausado durante playback, reanudado correctamente al finalizar  
‚úÖ **Contrato Snoop:** Estado READY confirmado por StasisStart, correlaci√≥n correcta (linkedId, parentChannelId)  
‚úÖ **AudioSource Decision:** Engine determina correctamente audioSource = snoopId 1769089785.1507 basado en contrato READY  
‚úÖ **Cleanup:** Bridges destruidos en StasisEnd, Redis keys limpiadas, contratos transicionan a DESTROYED

---

## 4) ERRORES Y ANOMAL√çAS DETECTADAS

‚ùå **[ARI / CANAL ENTRADA]** channels.get(snoopId) falla persistentemente con "Channel not found"  
üìå **Evidencia:**
```
13:49:45.472: [SNOOP] channels.get() fall√≥ (no cr√≠tico, StasisStart es fuente de verdad): {"message": "Channel not found"}
13:49:55.574: ‚ö†Ô∏è [STT INIT] channels.get() fall√≥ para Snoop 1769089785.1507 ({"message": "Channel not found"}), pero contrato confirma READY
13:50:01.181: ‚ö†Ô∏è [STT INIT] channels.get() fall√≥ para Snoop 1769089785.1507 ({"message": "Channel not found"}), pero contrato confirma READY
```
üìå **Afecta:** Canal de entrada (Snoop no materializado en ARI REST API)

‚ùå **[STT INIT / AUDIO-SAFE GATE]** Timeout esperando materializaci√≥n ARI del Snoop (5000ms, 50 intentos)  
üìå **Evidencia:**
```
13:50:00.666: ‚è±Ô∏è [AUDIO_READY] Timeout esperando materializaci√≥n de Snoop 1769089785.1507 (5000ms, 50 intentos)
13:50:00.666: ‚ùå [STT INIT] Audio-Safe Gate fall√≥: Snoop 1769089785.1507 no materializado en ARI despu√©s de timeout
13:50:00.667: ‚ùå [STT INIT] STT no inicializado: STT_BLOCKED_AUDIO_NOT_READY
```
üìå **Afecta:** Canal de entrada (STT bloqueado, no puede escuchar)

‚ùå **[TIMING / MATERIALIZACI√ìN]** Timeout previo en waitUntilChannelAvailable (2000ms) antes de Audio-Safe Gate  
üìå **Evidencia:**
```
13:49:47.737: ‚è±Ô∏è [STT INIT] Timeout esperando materializaci√≥n de canal 1769089785.1507 en ARI (2000ms) { attempts: 20, elapsedMs: 2036 }
```
üìå **Afecta:** Sincronizaci√≥n entre creaci√≥n Snoop y disponibilidad ARI REST

‚ùå **[ROLE / CLEANUP]** Rol perdido al hangup (Role: Unknown)  
üìå **Evidencia:**
```
13:49:44.880: ‚úÖ [ROLE] Rol asignado inmediatamente: canal 1769089784.1506 ‚Üí voicebot
13:50:03.805: üìû ChannelHangupRequest: 1769089784.1506 (..., Role: Unknown)
13:50:03.805: ‚ö†Ô∏è Hangup de canal sin rol definido: 1769089784.1506
```
üìå **Afecta:** Trazabilidad y auditor√≠a (s√≠ntoma, no causa ra√≠z)

‚ùå **[AUDIO SEGMENTS]** Segmento LISTEN_START incompleto (durationMs: 0)  
üìå **Evidencia:**
```
13:50:03.810: [AUDIO_SEGMENTS_RESOLVED] segments: [{ startMs: 10120, endMs: 10120, durationMs: 0, reason: 'incomplete' }]
```
üìå **Afecta:** Segmentaci√≥n de audio (consecuencia de STT bloqueado + hangup temprano)

---

## 5) COMPORTAMIENTOS INCORRECTOS DE ARQUITECTURA

‚ö†Ô∏è **[ARQUITECTURA]** Audio-Safe Gate bloquea STT bas√°ndose en channels.get() que no es fuente de verdad  
**Descripci√≥n:** El gate exige que `channels.get(snoopId)` retorne canal con state='Up', pero ARI REST no resuelve el Snoop aunque StasisStart ya fue recibido y el contrato est√° READY. Esto viola el principio de "eventos como fuente de verdad" y bloquea el flujo de audio.

‚ö†Ô∏è **[ARQUITECTURA]** Contrato Snoop READY no garantiza materializaci√≥n ARI REST  
**Descripci√≥n:** El sistema marca Snoop como READY bas√°ndose en StasisStart (evento), pero luego exige verificaci√≥n REST (polling) que falla. Esto crea una dependencia circular: READY requiere ARI, pero ARI no ve el canal aunque el evento confirma existencia.

‚ö†Ô∏è **[ARQUITECTURA]** Turn silente post-playback genera fricci√≥n temporal  
**Descripci√≥n:** Despu√©s de playback, Turn 1 se ejecuta como START_GREETING silent=true skipInput=true, enviando transcript vac√≠o al dominio. El dominio reci√©n en ese TURN ejecuta LISTEN_RUT. Esto reduce la ventana √∫til antes de que el usuario cuelgue.

---

## 5.1) INFORMACI√ìN ADICIONAL REQUERIDA

üîç **Informaci√≥n adicional requerida:**
Para confirmar la causa ra√≠z se requiere revisar:

**Archivo:** `services/core/engine/voice-engine.js`  
**Funci√≥n:** `ensureAudioReady()` (l√≠neas ~1037-1080)  
**Motivo:** El log no evidencia si el timeout de 5000ms es suficiente o si hay una condici√≥n de carrera entre StasisStart y disponibilidad REST API. Verificar si hay logs de ARI que indiquen por qu√© channels.get() falla persistentemente.

**Archivo:** `services/core/ari/ari-listener.js`  
**Funci√≥n:** Handler de StasisStart para Snoop  
**Motivo:** El log no evidencia si el Snoop se registra correctamente en el mapa de canales activos o si hay un desajuste entre el evento y el estado interno del listener.

---

## 6) CAUSA RA√çZ (ROOT CAUSE)

üéØ **Causa ra√≠z:**
El Audio-Safe Gate bloquea la inicializaci√≥n de STT porque exige materializaci√≥n del Snoop en ARI REST API (`channels.get(snoopId)` retorne canal con state='Up'), pero ARI REST no resuelve el canal aunque StasisStart ya confirm√≥ su existencia y el contrato est√° READY. El sistema conf√≠a en polling REST como gate bloqueante en lugar de usar eventos (StasisStart) como fuente de verdad √∫nica.

---

## 7) IMPACTO REAL EN EL USUARIO FINAL

üìû **Impacto:**
El usuario escucha el greeting completo (9.7s), pero cuando el bot intenta escuchar el RUT, el sistema queda bloqueado esperando una condici√≥n que nunca se cumple. El usuario habla pero no hay STT activo para capturar. Despu√©s de ~8 segundos de silencio, el usuario cuelga sin haber podido proporcionar su RUT. La experiencia es: "El bot habla, pero no escucha".

---

## 8) QU√â NO ES EL PROBLEMA

üö´ **No es:**
- Problema de Asterisk (StasisStart llega correctamente)
- Problema de Redis (contratos se persisten y leen correctamente)
- Problema de dise√±o de Snoop (se crea y correlaciona correctamente)
- Problema de archivo de audio (WAV existe y se reproduce)
- Problema de bridge (se crean y usan correctamente)
- Problema de dominio Quintero (decide correctamente LISTEN_RUT)
- Problema de lifecycle gating (valida correctamente permisos)

---

## 9) RECOMENDACIONES T√âCNICAS (SIN IMPLEMENTAR)

üõ†Ô∏è **Recomendaciones:**

**R1: Redefinir AUDIO_READY como primitiva basada en eventos**
**Motivo:** El log evidencia que StasisStart confirma existencia del Snoop, pero channels.get() falla persistentemente. El Audio-Safe Gate debe usar StasisStart + contrato READY + correlaci√≥n como fuente de verdad, no polling REST.

**R2: Degradar channels.get() a telemetr√≠a best-effort**
**Motivo:** El log muestra m√∫ltiples fallos de channels.get() que no deber√≠an bloquear el flujo. Convertir en verificaci√≥n as√≠ncrona opcional para m√©tricas, sin bloquear STT init.

**R3: Eliminar turn silente post-playback**
**Motivo:** El log muestra Turn 1 como START_GREETING silent=true generando fricci√≥n temporal. El engine debe cambiar fase a LISTEN_RUT inmediatamente despu√©s de playback antes del siguiente TURN.

**R4: Corregir logging de transici√≥n SnoopContract**
**Motivo:** El log muestra "CREATED ‚Üí READY" cuando actualFrom era "WAITING_AST", generando confusi√≥n en auditor√≠a. El log debe reflejar el estado real: WAITING_AST ‚Üí READY.

**R5: Persistir rol en Redis con TTL ligado a linkedId**
**Motivo:** El log muestra rol perdido al hangup (Role: Unknown). Persistir en Redis con TTL para mantener consistencia durante cleanup.

**R6: Emitir LISTEN_END sint√©tico en hangup si LISTEN_START activo**
**Motivo:** El log muestra segmento incompleto (durationMs: 0). Cerrar segmento forzadamente en hangup para evitar estados inconsistentes.

---

## 10) RESUMEN EJECUTIVO FINAL

El sistema inicia correctamente, crea recursos (bridges, Snoop) y reproduce el greeting. Al entrar a LISTEN_RUT, el Audio-Safe Gate bloquea STT porque exige materializaci√≥n del Snoop en ARI REST API, pero ARI REST no resuelve el canal aunque StasisStart ya confirm√≥ su existencia. El usuario cuelga sin poder proporcionar RUT.

**‚úÖ FIXES IMPLEMENTADOS:**
- `ensureAudioReady()` redefinido para usar eventos (StasisStart) + contrato READY como fuente de verdad
- `channels.get()` degradado a telemetr√≠a best-effort (no bloqueante)
- Logging de transici√≥n SnoopContract corregido (usa estado real, no solicitado)

**‚è≥ PENDIENTE:**
- Eliminar turn silente post-playback
- Persistir rol en Redis para consistencia en hangup
- Emitir LISTEN_END sint√©tico en hangup si LISTEN_START activo

---

## ANEXO: TIMELINE DETALLADO CON EVIDENCIA

| Timestamp (UTC) | Evento | Canal | Evidencia Log |
|----------------|--------|-------|---------------|
| 13:49:44.875 | StasisStart caller | Entrada | `‚úÖ [parseArgs] Usando event.args` |
| 13:49:45.434 | Fase START_GREETING | Engine | `üîí Fase inicial seteada: START_GREETING` |
| 13:49:45.450 | VoiceBridge creado | Salida | `‚úÖ Bridge de voz creado: 2b54f137-...` |
| 13:49:45.453 | Snoop RX creado | Entrada | `üïµÔ∏è‚Äç‚ôÇÔ∏è Snoop temprano creado: 1769089785.1507` |
| 13:49:45.458 | StasisStart SNOOP | Entrada | `üîî StasisStart RAW (SNOOP) channelId: 1769089785.1507` |
| 13:49:45.474 | SnoopContract READY | Entrada | `üìú SNOOP CONTRACT Transici√≥n: CREATED ‚Üí READY` |
| 13:49:45.625 | Playback iniciado | Salida | `‚úÖ Bridge.play iniciado, playbackId=5f063213-...` |
| 13:49:55.333 | Playback completado | Salida | `‚úÖ Playback completado: duraci√≥n 9696ms` |
| 13:49:55.556 | Turn 2 LISTEN_RUT | Engine | `üîÑ Turn 2 phase=LISTEN_RUT silent=false` |
| 13:49:55.576 | Audio-Safe Gate inicia | Entrada | `üîç Verificando Audio-Safe Gate para Snoop 1769089785.1507` |
| 13:50:00.666 | Audio-Safe Gate timeout | Entrada | `‚è±Ô∏è Timeout esperando materializaci√≥n (5000ms, 50 intentos)` |
| 13:50:00.667 | STT bloqueado | Entrada | `‚ùå STT_BLOCKED_AUDIO_NOT_READY` |
| 13:50:03.800 | Caller hangup | Entrada | `üîö Fin de llamada LinkedID=1769089784.1506` |

---

## ANEXO: INVARIANTES VERIFICADAS

### ‚úÖ Invariantes Cumplidas
- **I1:** START_GREETING no inicia STT ‚Üí STT pausado durante playback
- **I2:** START_GREETING requiere BRIDGE antes de PLAYBACK ‚Üí Bridge creado antes de reproducir
- **I3:** Archivo BVDA existe antes de reproducir ‚Üí Check filesystem OK
- **I4:** LISTEN_RUT exige BRIDGE+SNOOP ‚Üí Engine valida contrato y re-inserta caller
- **I5:** Cleanup en StasisEnd destruye bridges ‚Üí VoiceBridge destruido correctamente

### ‚ùå Invariantes Rotas
- **I6:** Snoop READY ‚áí ARI channels.get(snoopId) debe existir ‚Üí **ROTA** (READY por evento, pero channels.get() falla)
- **I7:** Segmentaci√≥n LISTEN_START debe cerrar con LISTEN_END ‚Üí **ROTA** (segmento incompleto, durationMs: 0)
- **I8:** Rol debe estar definido al hangup ‚Üí **ROTA** (Role: Unknown al finalizar)

---

## ANEXO: SINCRONIZACIONES VERIFICADAS

### ‚úÖ Sincronizaciones OK
- **S1:** systemd restart ‚Üí boot OK (Redis/MSSQL/ARI/WS)
- **S2:** Router ‚Üí Capsule ‚Üí Engine (routing correcto)
- **S3:** Lifecycle gating (permisos validados antes de acciones)
- **S4:** Playback execution (archivo existe, bridge.play() OK)
- **S5:** SnoopContract READY (StasisStart + correlaci√≥n OK)

### ‚ùå Sincronizaciones Rotas
- **S6:** Snoop READY vs materializaci√≥n ARI ‚Üí **ROTA** (READY por evento, pero ARI REST no resuelve)
- **S7:** Turn/Phase handoff post-playback ‚Üí **ROTA** (Turn silente genera fricci√≥n temporal)
- **S8:** Role lookup en hangup ‚Üí **ROTA** (Role: Unknown, p√©rdida de estado)

---

## ANEXO: NEXT ACTIONS (SIN PREGUNTAS)

### ‚úÖ IMPLEMENTADO
1. **‚úÖ Redefinir `ensureAudioReady()` para usar eventos como fuente de verdad**
   - ‚úÖ Cambiado: Usa `SnoopContract.state == READY` + correlaci√≥n como fuente de verdad
   - ‚úÖ Eliminado: Dependencia de `channels.get()` como gate bloqueante
   - ‚úÖ Mantenido: `channels.get()` como telemetr√≠a as√≠ncrona opcional (best-effort)
   - **Archivo:** `services/core/engine/voice-engine.js` l√≠neas ~1022-1095

2. **‚úÖ Corregir logging de transici√≥n SnoopContract**
   - ‚úÖ Usa `effectiveFrom` (estado real) en lugar de par√°metro `from` en logs
   - ‚úÖ Log refleja transici√≥n real: `WAITING_AST ‚Üí READY` (no `CREATED ‚Üí READY`)
   - **Archivo:** `services/core/engine/contracts/snoop.contract.js` l√≠neas ~208-257

### üî¥ PRIORIDAD 0 - PENDIENTE (BLOQUEANTE)
3. **Eliminar turn silente post-playback**
   - Cambiar fase a LISTEN_RUT inmediatamente despu√©s de `advanceTurnAfterPlayback`
   - O emitir evento interno `AFTER_PLAYBACK_ADVANCE` que ejecute SET_STATE sin transcript vac√≠o
   - **Archivo:** `services/core/engine/voice-engine.js` (buscar `advanceTurnAfterPlayback`)

### üü† PRIORIDAD 1 - PENDIENTE (CR√çTICO)
4. **Persistir rol en Redis con TTL ligado a linkedId**
   - Guardar `role:${linkedId}` en Redis con TTL = duraci√≥n esperada de llamada
   - Leer desde Redis en hangup handler antes de cleanup
   - **Archivo:** `services/core/ari/ari-listener.js` (handler de hangup)

5. **Emitir LISTEN_END sint√©tico en hangup si LISTEN_START activo**
   - En cleanup handler, verificar segmento activo
   - Si existe LISTEN_START sin LISTEN_END ‚Üí emitir LISTEN_END con reason=hangup
   - **Archivo:** `services/core/engine/voice-engine.js` (cleanup/hangup handler)

### üü° PRIORIDAD 2 - PENDIENTE (IMPORTANTE)
6. **Agregar log √∫nico de invariantes al final de llamada**
   - Formato: `INVARIANTS: voiceBridge=OK, snoop=READY, ariGet=FAIL, audioReady=OK(by_event), stt=BLOCKED(gate), role=INCONSISTENT, segments=INCOMPLETE`
   - Facilitar auditor√≠a masiva sin leer logs completos
   - **Archivo:** `services/core/engine/voice-engine.js` (finalizaci√≥n de sesi√≥n)

---

**FIN DEL AN√ÅLISIS FORENSE**
